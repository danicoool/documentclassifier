package documentclassifier;

import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.io.File;
import java.lang.Integer;
import java.util.AbstractMap;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.prefs.Preferences;
import javax.swing.JFileChooser;
import javax.swing.JTextField;
import javax.swing.filechooser.FileFilter;
import org.jdesktop.application.*;

/**
 * Questa classe rappresente il JDialog con la quale l'utente può modificare le
 * opzioni del programma, quale lo scraper usato per estrarre le features (i termini)
 * dai documenti, la metrica da utilizzare per calcolarne la distanza, ecc...
 * 
 * @author  Salvo Danilo Giuffrida (giuffsalvo@hotmail.it, salvodanilogiuffrida@gmail.com)
 */
public class PreferenzeDialog extends javax.swing.JDialog {
    
    private static final long serialVersionUID=1;
    
    private final DocumentClassifierApp application = DocumentClassifierApp.getApplication();
    private final Preferences preferenze = application.getPreferenze();
    /**
     * Un'istanza della classe {@link MappaPreferenzeDefault} è necessaria per poter
     * riferirsi in modo indiretto ai nomi delle varie preferenze, e se necessario
     * ai loro valori di default.
     */
    private final MappaPreferenzeDefault mappaPreferenze = application.getMappaPreferenze();
    private String trainingSetDirectory,  stopWordsList, logFile;

    /**
     *  Crea un nuovo PreferenzeDialog
     * 
     *  @param  parent      Il Frame padre di questo JDialog
     */
    protected PreferenzeDialog(FrameView parent, boolean modal) {
        super(parent.getFrame(), modal);
        initComponents();
        preferenze.addPreferenceChangeListener(application);
        preferenze.addPreferenceChangeListener((DocumentClassifierView) parent);
        inizializzaInterfaccia(false);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        bindingGroup = new org.jdesktop.beansbinding.BindingGroup();

        gruppoMetriche = new javax.swing.ButtonGroup();
        bottoneOK = new javax.swing.JButton();
        bottoneAnnulla = new javax.swing.JButton();
        bottoneReset = new javax.swing.JButton();
        tabbelPanePreferenze = new javax.swing.JTabbedPane();
        panelTrainingSet = new javax.swing.JPanel();
        labelDirectoryTrainingSet = new javax.swing.JLabel();
        fieldDirectoryTrainingSet = new javax.swing.JTextField();
        bottoneSfogliaDirectoryTrainingSet = new javax.swing.JButton();
        panelPreprocessing = new javax.swing.JPanel();
        labelParser = new javax.swing.JLabel();
        comboBoxScraper = new javax.swing.JComboBox();
        separatorScraperPreprocessing = new javax.swing.JSeparator();
        labelPreprocessing = new javax.swing.JLabel();
        checkBoxStopWords = new javax.swing.JCheckBox();
        labelStopWords = new javax.swing.JLabel();
        fieldStopWords = new javax.swing.JTextField();
        bottoneSfogliaStopWords = new javax.swing.JButton();
        checkBoxStemming = new javax.swing.JCheckBox();
        labelStemmerCorrente = new javax.swing.JLabel();
        comboBoxStemmers = new javax.swing.JComboBox();
        panelClassificazione = new javax.swing.JPanel();
        bottoneTFIDF = new javax.swing.JRadioButton();
        bottoneBhattacharrya = new javax.swing.JRadioButton();
        labelMetrica = new javax.swing.JLabel();
        sliderKNN = new javax.swing.JSlider();
        labelKNNTitle = new javax.swing.JLabel();
        separatorMetricaKNN = new javax.swing.JSeparator();
        labelKNNValue = new javax.swing.JLabel();
        panelValidazione = new javax.swing.JPanel();
        sliderKFold = new javax.swing.JSlider();
        labelKFoldTitle = new javax.swing.JLabel();
        separatorKFoldLogging = new javax.swing.JSeparator();
        checkBoxStratificazione = new javax.swing.JCheckBox();
        checkBoxVisualizzazioneListaDocumentiCorrelati = new javax.swing.JCheckBox();
        labelKFoldValue = new javax.swing.JLabel();
        separatorKNNMaximumKFold = new javax.swing.JSeparator();
        labelKNNMaximumTitle = new javax.swing.JLabel();
        labelKNNMaximumValue = new javax.swing.JLabel();
        sliderKNNMaximum = new javax.swing.JSlider();
        checkBoxVisualizzaInfoDocumentoCorrente = new javax.swing.JCheckBox();
        labelFileLog = new javax.swing.JLabel();
        fieldLogFile = new javax.swing.JTextField();
        bottoneSfogliaFileLog = new javax.swing.JButton();
        separatorFileLogVisualizza = new javax.swing.JSeparator();
        checkBoxLogging = new javax.swing.JCheckBox();
        checkBoxOverwriteLogFile = new javax.swing.JCheckBox();

        FormListener formListener = new FormListener();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(documentclassifier.DocumentClassifierApp.class).getContext().getResourceMap(PreferenzeDialog.class);
        setTitle(resourceMap.getString("Form.title")); // NOI18N
        setLocationByPlatform(true);
        setModal(true);
        setName("Form"); // NOI18N

        javax.swing.ActionMap actionMap = org.jdesktop.application.Application.getInstance(documentclassifier.DocumentClassifierApp.class).getContext().getActionMap(PreferenzeDialog.class, this);
        bottoneOK.setAction(actionMap.get("OKPreferenze")); // NOI18N
        bottoneOK.setName("bottoneOK"); // NOI18N

        bottoneAnnulla.setAction(actionMap.get("annullaPreferenze")); // NOI18N
        bottoneAnnulla.setName("bottoneAnnulla"); // NOI18N

        bottoneReset.setAction(actionMap.get("resettaPreferenze")); // NOI18N
        bottoneReset.setName("bottoneReset"); // NOI18N

        tabbelPanePreferenze.setName("tabbelPanePreferenze"); // NOI18N

        panelTrainingSet.setName("panelTrainingSet"); // NOI18N

        labelDirectoryTrainingSet.setLabelFor(fieldDirectoryTrainingSet);
        labelDirectoryTrainingSet.setText(resourceMap.getString("labelDirectoryTrainingSet.text")); // NOI18N
        labelDirectoryTrainingSet.setName("labelDirectoryTrainingSet"); // NOI18N

        fieldDirectoryTrainingSet.setText(resourceMap.getString("fieldDirectoryTrainingSet.text")); // NOI18N
        fieldDirectoryTrainingSet.setName("fieldDirectoryTrainingSet"); // NOI18N
        fieldDirectoryTrainingSet.addFocusListener(formListener);

        bottoneSfogliaDirectoryTrainingSet.setText(resourceMap.getString("bottoneSfogliaDirectoryTrainingSet.text")); // NOI18N
        bottoneSfogliaDirectoryTrainingSet.setName("bottoneSfogliaDirectoryTrainingSet"); // NOI18N
        bottoneSfogliaDirectoryTrainingSet.addActionListener(formListener);

        javax.swing.GroupLayout panelTrainingSetLayout = new javax.swing.GroupLayout(panelTrainingSet);
        panelTrainingSet.setLayout(panelTrainingSetLayout);
        panelTrainingSetLayout.setHorizontalGroup(
            panelTrainingSetLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelTrainingSetLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(labelDirectoryTrainingSet)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(fieldDirectoryTrainingSet, javax.swing.GroupLayout.DEFAULT_SIZE, 385, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(bottoneSfogliaDirectoryTrainingSet)
                .addContainerGap())
        );
        panelTrainingSetLayout.setVerticalGroup(
            panelTrainingSetLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelTrainingSetLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelTrainingSetLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelDirectoryTrainingSet)
                    .addComponent(bottoneSfogliaDirectoryTrainingSet)
                    .addComponent(fieldDirectoryTrainingSet, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(323, Short.MAX_VALUE))
        );

        tabbelPanePreferenze.addTab(resourceMap.getString("panelTrainingSet.TabConstraints.tabTitle"), panelTrainingSet); // NOI18N

        panelPreprocessing.setName("panelPreprocessing"); // NOI18N

        labelParser.setLabelFor(comboBoxScraper);
        labelParser.setText(resourceMap.getString("labelParser.text")); // NOI18N
        labelParser.setName("labelParser"); // NOI18N

        comboBoxScraper.setName("comboBoxScraper"); // NOI18N

        separatorScraperPreprocessing.setName("separatorScraperPreprocessing"); // NOI18N

        labelPreprocessing.setText(resourceMap.getString("labelPreprocessing.text")); // NOI18N
        labelPreprocessing.setName("labelPreprocessing"); // NOI18N

        checkBoxStopWords.setSelected(true);
        checkBoxStopWords.setText(resourceMap.getString("checkBoxStopWords.text")); // NOI18N
        checkBoxStopWords.setName("checkBoxStopWords"); // NOI18N
        checkBoxStopWords.addChangeListener(formListener);

        labelStopWords.setLabelFor(fieldStopWords);
        labelStopWords.setText(resourceMap.getString("labelStopWords.text")); // NOI18N
        labelStopWords.setName("labelStopWords"); // NOI18N

        fieldStopWords.setName("fieldStopWords"); // NOI18N
        fieldStopWords.addFocusListener(formListener);

        bottoneSfogliaStopWords.setText(resourceMap.getString("bottoneSfogliaStopWords.text")); // NOI18N
        bottoneSfogliaStopWords.setName("bottoneSfogliaStopWords"); // NOI18N
        bottoneSfogliaStopWords.addActionListener(formListener);

        checkBoxStemming.setSelected(true);
        checkBoxStemming.setText(resourceMap.getString("checkBoxStemming.text")); // NOI18N
        checkBoxStemming.setName("checkBoxStemming"); // NOI18N
        checkBoxStemming.addChangeListener(formListener);

        labelStemmerCorrente.setLabelFor(checkBoxStemming);
        labelStemmerCorrente.setText(resourceMap.getString("labelStemmerCorrente.text")); // NOI18N
        labelStemmerCorrente.setName("labelStemmerCorrente"); // NOI18N

        comboBoxStemmers.setName("comboBoxStemmers"); // NOI18N

        javax.swing.GroupLayout panelPreprocessingLayout = new javax.swing.GroupLayout(panelPreprocessing);
        panelPreprocessing.setLayout(panelPreprocessingLayout);
        panelPreprocessingLayout.setHorizontalGroup(
            panelPreprocessingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelPreprocessingLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelPreprocessingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(separatorScraperPreprocessing, javax.swing.GroupLayout.DEFAULT_SIZE, 593, Short.MAX_VALUE)
                    .addGroup(panelPreprocessingLayout.createSequentialGroup()
                        .addComponent(labelParser)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(comboBoxScraper, 0, 528, Short.MAX_VALUE))
                    .addComponent(labelPreprocessing)
                    .addGroup(panelPreprocessingLayout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addGroup(panelPreprocessingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(panelPreprocessingLayout.createSequentialGroup()
                                .addGap(12, 12, 12)
                                .addComponent(labelStopWords, javax.swing.GroupLayout.PREFERRED_SIZE, 110, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(fieldStopWords, javax.swing.GroupLayout.DEFAULT_SIZE, 387, Short.MAX_VALUE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(bottoneSfogliaStopWords))
                            .addComponent(checkBoxStopWords)
                            .addComponent(checkBoxStemming)
                            .addGroup(panelPreprocessingLayout.createSequentialGroup()
                                .addGap(12, 12, 12)
                                .addComponent(labelStemmerCorrente)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(comboBoxStemmers, 0, 497, Short.MAX_VALUE)))))
                .addContainerGap())
        );
        panelPreprocessingLayout.setVerticalGroup(
            panelPreprocessingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelPreprocessingLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelPreprocessingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelParser)
                    .addComponent(comboBoxScraper, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(separatorScraperPreprocessing, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(labelPreprocessing)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkBoxStopWords)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(panelPreprocessingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelStopWords)
                    .addComponent(fieldStopWords, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(bottoneSfogliaStopWords))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkBoxStemming)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(panelPreprocessingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelStemmerCorrente)
                    .addComponent(comboBoxStemmers, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(178, Short.MAX_VALUE))
        );

        tabbelPanePreferenze.addTab(resourceMap.getString("panelPreprocessing.TabConstraints.tabTitle"), panelPreprocessing); // NOI18N

        panelClassificazione.setName("panelClassificazione"); // NOI18N

        gruppoMetriche.add(bottoneTFIDF);
        bottoneTFIDF.setSelected(true);
        bottoneTFIDF.setText(resourceMap.getString("bottoneTFIDF.text")); // NOI18N
        bottoneTFIDF.setName("bottoneTFIDF"); // NOI18N

        gruppoMetriche.add(bottoneBhattacharrya);
        bottoneBhattacharrya.setText(resourceMap.getString("bottoneBhattacharrya.text")); // NOI18N
        bottoneBhattacharrya.setName("bottoneBhattacharrya"); // NOI18N

        labelMetrica.setText(resourceMap.getString("labelMetrica.text")); // NOI18N
        labelMetrica.setToolTipText(resourceMap.getString("labelMetrica.toolTipText")); // NOI18N
        labelMetrica.setName("labelMetrica"); // NOI18N

        sliderKNN.setMaximum(application.getKNNMaximum());
        sliderKNN.setMinimum(1);
        sliderKNN.setValue(sliderKNN.getMinimum());
        sliderKNN.setName("sliderKNN"); // NOI18N

        labelKNNTitle.setText(resourceMap.getString("labelKNNTitle.text")); // NOI18N
        labelKNNTitle.setName("labelKNNTitle"); // NOI18N

        separatorMetricaKNN.setName("separatorMetricaKNN"); // NOI18N

        labelKNNValue.setName("labelKNNValue"); // NOI18N

        org.jdesktop.beansbinding.Binding binding = org.jdesktop.beansbinding.Bindings.createAutoBinding(org.jdesktop.beansbinding.AutoBinding.UpdateStrategy.READ_WRITE, sliderKNN, org.jdesktop.beansbinding.ELProperty.create("${value}"), labelKNNValue, org.jdesktop.beansbinding.BeanProperty.create("text"));
        bindingGroup.addBinding(binding);

        javax.swing.GroupLayout panelClassificazioneLayout = new javax.swing.GroupLayout(panelClassificazione);
        panelClassificazione.setLayout(panelClassificazioneLayout);
        panelClassificazioneLayout.setHorizontalGroup(
            panelClassificazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelClassificazioneLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelClassificazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(separatorMetricaKNN, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 593, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, panelClassificazioneLayout.createSequentialGroup()
                        .addComponent(labelMetrica)
                        .addGap(7, 7, 7)
                        .addGroup(panelClassificazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(bottoneBhattacharrya)
                            .addComponent(bottoneTFIDF)))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, panelClassificazioneLayout.createSequentialGroup()
                        .addComponent(labelKNNTitle, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelKNNValue, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(sliderKNN, javax.swing.GroupLayout.DEFAULT_SIZE, 503, Short.MAX_VALUE)))
                .addContainerGap())
        );
        panelClassificazioneLayout.setVerticalGroup(
            panelClassificazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelClassificazioneLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelClassificazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(bottoneTFIDF)
                    .addComponent(labelMetrica))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(bottoneBhattacharrya)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(separatorMetricaKNN, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(panelClassificazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(panelClassificazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(labelKNNTitle, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(labelKNNValue))
                    .addComponent(sliderKNN, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(244, Short.MAX_VALUE))
        );

        tabbelPanePreferenze.addTab(resourceMap.getString("panelClassificazione.TabConstraints.tabTitle"), panelClassificazione); // NOI18N

        panelValidazione.setName("panelValidazione"); // NOI18N

        sliderKFold.setMaximum(application.getKFoldMaximum());
        sliderKFold.setMinimum(application.getKFoldMinimum());
        sliderKFold.setValue(application.getKFold(false));
        sliderKFold.setName("sliderKFold"); // NOI18N
        sliderKFold.addChangeListener(formListener);

        labelKFoldTitle.setText(resourceMap.getString("labelKFoldTitle.text")); // NOI18N
        labelKFoldTitle.setName("labelKFoldTitle"); // NOI18N

        separatorKFoldLogging.setName("separatorKFoldLogging"); // NOI18N

        checkBoxStratificazione.setText(resourceMap.getString("checkBoxStratificazione.text")); // NOI18N
        checkBoxStratificazione.setName("checkBoxStratificazione"); // NOI18N
        checkBoxStratificazione.addChangeListener(formListener);

        checkBoxVisualizzazioneListaDocumentiCorrelati.setText(resourceMap.getString("checkBoxVisualizzazioneListaDocumentiCorrelati.text")); // NOI18N
        checkBoxVisualizzazioneListaDocumentiCorrelati.setName("checkBoxVisualizzazioneListaDocumentiCorrelati"); // NOI18N

        labelKFoldValue.setName("labelKFoldValue"); // NOI18N

        binding = org.jdesktop.beansbinding.Bindings.createAutoBinding(org.jdesktop.beansbinding.AutoBinding.UpdateStrategy.READ_WRITE, sliderKFold, org.jdesktop.beansbinding.ELProperty.create("${value}"), labelKFoldValue, org.jdesktop.beansbinding.BeanProperty.create("text"));
        bindingGroup.addBinding(binding);

        separatorKNNMaximumKFold.setName("separatorKNNMaximumKFold"); // NOI18N

        labelKNNMaximumTitle.setText(resourceMap.getString("labelKNNMaximumTitle.text")); // NOI18N
        labelKNNMaximumTitle.setName("labelKNNMaximumTitle"); // NOI18N

        labelKNNMaximumValue.setName("labelKNNMaximumValue"); // NOI18N

        binding = org.jdesktop.beansbinding.Bindings.createAutoBinding(org.jdesktop.beansbinding.AutoBinding.UpdateStrategy.READ_WRITE, sliderKNNMaximum, org.jdesktop.beansbinding.ELProperty.create("${value}"), labelKNNMaximumValue, org.jdesktop.beansbinding.BeanProperty.create("text"));
        bindingGroup.addBinding(binding);

        sliderKNNMaximum.setMaximum((application.getTrainingSetSize()/application.getKFold(false))*(application.getKFold(false)-1));
        sliderKNNMaximum.setMinimum(sliderKNN.getMinimum());
        sliderKNNMaximum.setValue(sliderKNNMaximum.getMinimum());
        sliderKNNMaximum.setName("sliderKNNMaximum"); // NOI18N

        checkBoxVisualizzaInfoDocumentoCorrente.setText(resourceMap.getString("checkBoxVisualizzaInfoDocumentoCorrente.text")); // NOI18N
        checkBoxVisualizzaInfoDocumentoCorrente.setName("checkBoxVisualizzaInfoDocumentoCorrente"); // NOI18N

        labelFileLog.setText(resourceMap.getString("labelFileLog.text")); // NOI18N
        labelFileLog.setName("labelFileLog"); // NOI18N

        fieldLogFile.setText(resourceMap.getString("fieldLogFile.text")); // NOI18N
        fieldLogFile.setName("fieldLogFile"); // NOI18N

        bottoneSfogliaFileLog.setText(resourceMap.getString("bottoneSfogliaFileLog.text")); // NOI18N
        bottoneSfogliaFileLog.setName("bottoneSfogliaFileLog"); // NOI18N
        bottoneSfogliaFileLog.addActionListener(formListener);

        separatorFileLogVisualizza.setName("separatorFileLogVisualizza"); // NOI18N

        checkBoxLogging.setSelected(true);
        checkBoxLogging.setText(resourceMap.getString("checkBoxLogging.text")); // NOI18N
        checkBoxLogging.setName("checkBoxLogging"); // NOI18N
        checkBoxLogging.addItemListener(formListener);

        checkBoxOverwriteLogFile.setSelected(true);
        checkBoxOverwriteLogFile.setText(resourceMap.getString("checkBoxOverwriteLogFile.text")); // NOI18N
        checkBoxOverwriteLogFile.setName("checkBoxOverwriteLogFile"); // NOI18N

        javax.swing.GroupLayout panelValidazioneLayout = new javax.swing.GroupLayout(panelValidazione);
        panelValidazione.setLayout(panelValidazioneLayout);
        panelValidazioneLayout.setHorizontalGroup(
            panelValidazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelValidazioneLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelValidazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(separatorFileLogVisualizza, javax.swing.GroupLayout.DEFAULT_SIZE, 593, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, panelValidazioneLayout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addComponent(checkBoxStratificazione))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, panelValidazioneLayout.createSequentialGroup()
                        .addComponent(labelKFoldTitle)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelKFoldValue, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(sliderKFold, javax.swing.GroupLayout.DEFAULT_SIZE, 399, Short.MAX_VALUE))
                    .addComponent(separatorKFoldLogging, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 593, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, panelValidazioneLayout.createSequentialGroup()
                        .addComponent(labelKNNMaximumTitle)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelKNNMaximumValue, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(sliderKNNMaximum, javax.swing.GroupLayout.DEFAULT_SIZE, 453, Short.MAX_VALUE))
                    .addComponent(separatorKNNMaximumKFold, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 593, Short.MAX_VALUE)
                    .addComponent(checkBoxLogging, javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(panelValidazioneLayout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addComponent(labelFileLog)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(fieldLogFile, javax.swing.GroupLayout.DEFAULT_SIZE, 350, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(bottoneSfogliaFileLog)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(checkBoxOverwriteLogFile))
                    .addComponent(checkBoxVisualizzaInfoDocumentoCorrente, javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(checkBoxVisualizzazioneListaDocumentiCorrelati, javax.swing.GroupLayout.Alignment.LEADING))
                .addContainerGap())
        );
        panelValidazioneLayout.setVerticalGroup(
            panelValidazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelValidazioneLayout.createSequentialGroup()
                .addGroup(panelValidazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(panelValidazioneLayout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(panelValidazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(panelValidazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(labelKNNMaximumTitle)
                                .addComponent(labelKNNMaximumValue))
                            .addComponent(sliderKNNMaximum, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(separatorKNNMaximumKFold, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(panelValidazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(panelValidazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(labelKFoldTitle)
                                .addComponent(labelKFoldValue))
                            .addComponent(sliderKFold, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(checkBoxStratificazione)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(separatorKFoldLogging, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(checkBoxLogging))
                    .addGroup(panelValidazioneLayout.createSequentialGroup()
                        .addGap(199, 199, 199)
                        .addGroup(panelValidazioneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(labelFileLog)
                            .addComponent(fieldLogFile, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(bottoneSfogliaFileLog)
                            .addComponent(checkBoxOverwriteLogFile))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(separatorFileLogVisualizza, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkBoxVisualizzaInfoDocumentoCorrente)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkBoxVisualizzazioneListaDocumentiCorrelati)
                .addContainerGap(58, Short.MAX_VALUE))
        );

        tabbelPanePreferenze.addTab(resourceMap.getString("panelValidazione.TabConstraints.tabTitle"), panelValidazione); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(bottoneOK)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(bottoneAnnulla)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(bottoneReset)
                .addContainerGap(427, Short.MAX_VALUE))
            .addComponent(tabbelPanePreferenze, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 625, Short.MAX_VALUE)
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {bottoneAnnulla, bottoneOK, bottoneReset});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(tabbelPanePreferenze, javax.swing.GroupLayout.DEFAULT_SIZE, 397, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(bottoneOK)
                    .addComponent(bottoneAnnulla)
                    .addComponent(bottoneReset))
                .addContainerGap())
        );

        bindingGroup.bind();

        pack();
    }

    // Code for dispatching events from components to event handlers.

    private class FormListener implements java.awt.event.ActionListener, java.awt.event.FocusListener, java.awt.event.ItemListener, javax.swing.event.ChangeListener {
        FormListener() {}
        public void actionPerformed(java.awt.event.ActionEvent evt) {
            if (evt.getSource() == bottoneSfogliaDirectoryTrainingSet) {
                PreferenzeDialog.this.sfogliaFiles(evt);
            }
            else if (evt.getSource() == bottoneSfogliaStopWords) {
                PreferenzeDialog.this.sfogliaFiles(evt);
            }
            else if (evt.getSource() == bottoneSfogliaFileLog) {
                PreferenzeDialog.this.sfogliaFiles(evt);
            }
        }

        public void focusGained(java.awt.event.FocusEvent evt) {
        }

        public void focusLost(java.awt.event.FocusEvent evt) {
            if (evt.getSource() == fieldDirectoryTrainingSet) {
                PreferenzeDialog.this.controlloPercorso(evt);
            }
            else if (evt.getSource() == fieldStopWords) {
                PreferenzeDialog.this.controlloPercorso(evt);
            }
        }

        public void itemStateChanged(java.awt.event.ItemEvent evt) {
            if (evt.getSource() == checkBoxLogging) {
                PreferenzeDialog.this.checkBoxLoggingItemStateChanged(evt);
            }
        }

        public void stateChanged(javax.swing.event.ChangeEvent evt) {
            if (evt.getSource() == checkBoxStopWords) {
                PreferenzeDialog.this.checkBoxStopWordsStateChanged(evt);
            }
            else if (evt.getSource() == checkBoxStemming) {
                PreferenzeDialog.this.checkBoxStemmingStateChanged(evt);
            }
            else if (evt.getSource() == sliderKFold) {
                PreferenzeDialog.this.sistemaKFold(evt);
            }
            else if (evt.getSource() == checkBoxStratificazione) {
                PreferenzeDialog.this.sistemaKFold(evt);
            }
        }
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * Questo metodo aggiorna il valore della preferenza specificata nel 1° parametro
     * con il nuovo valore specificato nel 3° parametro, se esso è diverso dal valore
     * corrente
     * 
     * @param nomePreferenza    Il nome della preferenza di cui aggiornare il valore
     * @param valoreDefault     Il valore di default di tale preferenza
     * @param valoreAggiornato  Il nuovo valore da assegnare alla preferenza
     */
    private void aggiornaPreferenza(String nomePreferenza, String valoreDefault, String valoreAggiornato) {
        
        if (!preferenze.get(nomePreferenza, valoreDefault).equals(valoreAggiornato)) {
            preferenze.put(nomePreferenza, valoreAggiornato);
        }
    }
    
    /**
     * Questo metodo, dichiarato come azione, viene chiamato ogni volta che l'utente preme il pulsante
     * 'Annulla' dell'interfaccia grafica. Il suo unico compito è chiudere la relativa finestra
     */
    @Action
    public void annullaPreferenze() {
        dispose();
    }
    
    /**
     * Questo metodo viene chiamato in fase di creazione dell'interfaccia grafica, ogni volta che l'utente
     * decide di aprire questo Dialog, facendo click sulla voce 'Modifica'->'Preferenze' della barra dei menù.
     * <p>
     * Esso inizializza i vari componenti dell'interfaccia grafica, in base ai valori delle varie preferenze,
     * letti dalla classe che rappresenta il nucleo dell'applicazione, {@link DocumentClassifierApp}.
     * 
     * @param reset             Valore booleano che indica se i componenti dell'interfaccia grafica devono
     *                          essere (re)inizializzati con i valori di default delle varie preferenze, o
     *                          se invece devono utilizzare i valori correnti delle preferenze
     */
    private void inizializzaInterfaccia(boolean reset) {
        try {
            /**
             * Per prima cosa vengono disattivati temporaneamente tutti i focus listeners registrati
             * con i vari componenti della interfaccia grafica, in modo da evitare che essi vengano
             * richiamati mentre i rispettivi componenti vengono aggiornati
             */
            FocusListener[] focusListenersTrainingSet = fieldDirectoryTrainingSet.getFocusListeners();
            for (FocusListener FL : focusListenersTrainingSet) {
                fieldDirectoryTrainingSet.removeFocusListener(FL);
            }

            FocusListener[] focusListenersStopWords = fieldStopWords.getFocusListeners();
            for (FocusListener FL : focusListenersStopWords) {
                fieldStopWords.removeFocusListener(FL);
            }

            /**
             * Setto le proprietà dell'interfaccia grafica in base ai valori letti dal nodo delle preferenze
             */
            
            //Il percorso della directory del training set
            trainingSetDirectory = application.getDirectoryTrainingSet(reset);
            fieldDirectoryTrainingSet.setText(trainingSetDirectory);
            
            //Scraper corrente
            String nomeScraper = application.getScraper(reset).getClass().getName();
            List<Class> scrapers = DocumentClassifierApp.getClassesForPackage(application.getScrapersPackageName());
            if (scrapers.isEmpty()) {
                throw new Exception("Errore: Nessuno scraper trovato");
            }
            String nomeScraperCorrente;
            for (Class scraperCorrente : scrapers) {
                nomeScraperCorrente = scraperCorrente.getName();
                if (!nomeScraperCorrente.endsWith(".Scraper")) {
                    //Qual'è il parser da utilizzare
                    Class scraperClass = Class.forName(nomeScraperCorrente);
                    Object scraperInstance = scraperClass.newInstance();
                    comboBoxScraper.addItem(scraperInstance);
                    if (scraperInstance.getClass().getName().equals(nomeScraper)) {
                        comboBoxScraper.setSelectedItem(scraperInstance);
                    }
                }
            }
            
            //Se l'eliminazione delle stop words è attivata o no
            checkBoxStopWords.setSelected(application.isEliminazioneStopWords(reset));
            fieldStopWords.setEnabled(checkBoxStopWords.isSelected());

            //Il percorso del file con la lista delle stop words
            stopWordsList = application.getListaStopWords(reset);
            fieldStopWords.setText(stopWordsList);

            //Se lo stemming è attivato o no
            checkBoxStemming.setSelected(application.isStemming(reset));
            comboBoxStemmers.setEnabled(checkBoxStemming.isSelected());

            //Lo stemmer corrente
            String nomeStemmer = application.getStemmer(reset);
            List<Class> stemmers = DocumentClassifierApp.getClassesForPackage(application.getStemmersPackageName());
            if (stemmers.isEmpty() && checkBoxStemming.isSelected()) {
                throw new Exception("Errore: Nessuno stemmer trovato");
            }
            String nomeStemmerCorrente, nomeStemmerCorrenteRidotto;
            for (Class stemmerCorrente : stemmers) {
                nomeStemmerCorrente = stemmerCorrente.getName();
                nomeStemmerCorrenteRidotto = nomeStemmerCorrente.substring(nomeStemmerCorrente.indexOf("ext.") + 4);
                comboBoxStemmers.addItem(nomeStemmerCorrenteRidotto);
                if (nomeStemmerCorrente.equals(nomeStemmer)) {
                    comboBoxStemmers.setSelectedItem(nomeStemmerCorrenteRidotto);
                }
            }

            //La metrica corrente
            if (application.getMetrica(reset).equals("TF-IDF")) {
                bottoneTFIDF.setSelected(true);
            } else {
                bottoneBhattacharrya.setSelected(true);
            }

            //Il valore di K per il K-NN
            sliderKNN.setValue(application.getKNN(reset));
            
            //Il valore massimo di K per il K-NN durante la fase di validazione
            sliderKNNMaximum.setValue(application.getMaximumKNNValidation(reset));
            
            //Il valore di K per il K-Fold
            sliderKFold.setValue(application.getKFold(reset));

            //Se il partizionamento per la K-Fold cross validation deve essere stratificato
            checkBoxStratificazione.setSelected(application.isStratificato(reset));
            
            //Se il logging della fase di validazione è abilitato
            checkBoxLogging.setSelected(application.isLogging(reset));
            
            //Il percorso del file di log
            logFile=application.getLogFile(reset);
            fieldLogFile.setText(logFile);
            
            //Se il file di log deve essere sovrascritto ad ogni apertura
            checkBoxOverwriteLogFile.setSelected(application.isOverwriteLogFile(reset));
            
            //Se il documento corrente deve essere visualizzato durante la fase di validazione
            checkBoxVisualizzaInfoDocumentoCorrente.setSelected(application.isVisualizzaDocumentoCorrente(reset));
            
            //Se la lista delle pagine correlate ad ogni documento esaminato deve essere visualizzata durante la fase di validazione o no
            checkBoxVisualizzazioneListaDocumentiCorrelati.setSelected(application.isVisualizzaListaDocumenti(reset));
            
            /**
             * I focus listeners vengono riattivati
             */
            for (FocusListener FL : focusListenersStopWords) {
                fieldStopWords.addFocusListener(FL);
            }

            for (FocusListener FL : focusListenersTrainingSet) {
                fieldDirectoryTrainingSet.addFocusListener(FL);
            }

        } catch (Exception ex) {
            DocumentClassifierView.mostraMessaggioErrore(ex.toString());
        }
    }
    
    /**
     * Questo metodo, dichiarato come azione, viene chiamato ogni volta che l'utente preme il pulsante
     * 'OK' dell'interfaccia grafica. Esso ha quindi il compito di aggiornare i valori delle preferenze
     * corrispondenti a quei componenti dell'interfaccia grafica che hanno subito modifiche nel loro
     * valore e/o stato
     */
    @Action
    public void OKPreferenze() {
        
        String chiaveCorrente;
        
        chiaveCorrente=MappaPreferenzeDefault.SCRAPER;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), comboBoxScraper.getSelectedItem().getClass().getName());
        
        chiaveCorrente=MappaPreferenzeDefault.isELIMINAZIONESTOPWORDS;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(checkBoxStopWords.isSelected()));
        
        if (checkBoxStopWords.isSelected()) {
            controlloPercorso(new FocusEvent(fieldStopWords, FocusEvent.FOCUS_LOST));
        }
        chiaveCorrente=MappaPreferenzeDefault.LISTASTOPWORDS;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), fieldStopWords.getText());
        
        chiaveCorrente=MappaPreferenzeDefault.isSTEMMING;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(checkBoxStemming.isSelected()));
        
        chiaveCorrente=MappaPreferenzeDefault.STEMMER;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), application.getStemmersPackageName() + "." + ((String) comboBoxStemmers.getSelectedItem()));
        
        controlloPercorso(new FocusEvent(fieldDirectoryTrainingSet, FocusEvent.FOCUS_LOST));
        chiaveCorrente=MappaPreferenzeDefault.TRAININGSET;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), fieldDirectoryTrainingSet.getText());
        
        chiaveCorrente=MappaPreferenzeDefault.METRICA;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), (bottoneTFIDF.isSelected()) ? "TF-IDF" : "Bhattacharrya");
        
        chiaveCorrente=MappaPreferenzeDefault.KNN;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(sliderKNN.getValue()));
        
        chiaveCorrente=MappaPreferenzeDefault.MAXKNNVALIDATION;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(sliderKNNMaximum.getValue()));
        
        chiaveCorrente=MappaPreferenzeDefault.KFOLD;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(sliderKFold.getValue()));
        
        chiaveCorrente=MappaPreferenzeDefault.isSTRATIFICATO;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(checkBoxStratificazione.isSelected()));
        
        chiaveCorrente=MappaPreferenzeDefault.isLOGGING;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(checkBoxLogging.isSelected()));
        
        chiaveCorrente=MappaPreferenzeDefault.LOGFILE;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(fieldLogFile.getText()));
        
        chiaveCorrente=MappaPreferenzeDefault.isOVERWRITELOGFILE;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(checkBoxOverwriteLogFile.isSelected()));
        
        chiaveCorrente=MappaPreferenzeDefault.isVISUALIZZADOCUMENTOCORRENTE;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(checkBoxVisualizzaInfoDocumentoCorrente.isSelected()));
        
        chiaveCorrente=MappaPreferenzeDefault.isVISUALIZZALISTADOCUMENTICORRELATI;
        aggiornaPreferenza(chiaveCorrente, mappaPreferenze.get(chiaveCorrente), String.valueOf(checkBoxVisualizzazioneListaDocumentiCorrelati.isSelected()));
        
        //Una volta salvati i valori di tutte le preferenze modificate, chiudo la finestra dell'interfaccia grafica
        dispose();
    }

    @Action
    public void resettaPreferenze() {
        inizializzaInterfaccia(true);
    }
    
    /**
     * Questo metodo viene chiamato ogni volta che c'è la necessità di aprire un JFileDialog per selezionare
     * un file o una directory dal file system
     * 
     * @param evt
     */
private void sfogliaFiles(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sfogliaFiles
    try {
        JFileChooser fileChooser = new JFileChooser();
        Object source=evt.getSource();
        boolean isTrainingSet = source.equals(bottoneSfogliaDirectoryTrainingSet);
        boolean isListaStopwords=source.equals(bottoneSfogliaStopWords);
        if (isTrainingSet) {
            fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            fileChooser.setCurrentDirectory(new File(trainingSetDirectory).getParentFile());
        } else if (isListaStopwords) {
            fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
            fileChooser.setCurrentDirectory(new File(stopWordsList).getParentFile());
            fileChooser.removeChoosableFileFilter(fileChooser.getAcceptAllFileFilter());
            fileChooser.setFileFilter(new FileFilter() {

                @Override
                public boolean accept(File arg) {
                    if (arg.getName().toLowerCase().endsWith(".txt") || arg.isDirectory()) {
                        return true;
                    } else {
                        return false;
                    }
                }

                @Override
                public String getDescription() {
                    return "Text files (.txt)";
                }
            });
        } else {
            fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            fileChooser.setCurrentDirectory((new File(logFile).getParentFile()));
        }
        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            String newPath = fileChooser.getSelectedFile().getCanonicalPath();
            if (isTrainingSet && application.generaTrainingSet(newPath)) {
                fieldDirectoryTrainingSet.setText(newPath);
                controlloPercorso(new FocusEvent(fieldDirectoryTrainingSet, FocusEvent.FOCUS_LOST));
            } else if (isListaStopwords) {
                fieldStopWords.setText(newPath);
                controlloPercorso(new FocusEvent(fieldStopWords, FocusEvent.FOCUS_LOST));
            } else {
                fieldLogFile.setText(newPath);
            }
        }
    } catch (Exception ex) {
        DocumentClassifierView.mostraMessaggioErrore(ex.toString());
        ex.printStackTrace();
    }
}//GEN-LAST:event_sfogliaFiles

private void checkBoxStemmingStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_checkBoxStemmingStateChanged
    comboBoxStemmers.setEnabled(checkBoxStemming.isSelected());
}//GEN-LAST:event_checkBoxStemmingStateChanged

private void checkBoxStopWordsStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_checkBoxStopWordsStateChanged
    fieldStopWords.setEnabled(checkBoxStopWords.isSelected());
}//GEN-LAST:event_checkBoxStopWordsStateChanged

    /**
     * Questo metodo viene chiamato ogni volta che il percorso specificato in uno dei JTextFields
     * dell'interfaccia grafica viene modificato dall'utente, e controlla se il nuovo valore è valido,
     * se rappresenta cioè un file con una lista di stopwords valido, o una directory di un training set
     * strutturata in modo corretto.
     * 
     * @param evt           Il FocusEvent generato dal cambio di focus da uno dei JTextFields dell'interfaccia grafica
     */
private void controlloPercorso(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_controlloPercorso

    JTextField referenceField = (JTextField) evt.getSource();
    String oldPath;
    boolean isTrainingSet = (referenceField == fieldDirectoryTrainingSet);
    if (isTrainingSet) {
        oldPath = trainingSetDirectory;
    } else {
        oldPath = stopWordsList;
    }
    String newPath = referenceField.getText();
    if (!newPath.equals(oldPath)) {
        try {
            if (isTrainingSet) {
                //Controllo della directory del training set
                if (application.generaTrainingSet(newPath)) {
                    trainingSetDirectory = newPath;
                    sliderKNN.setMaximum(application.getKNNMaximum());
                    sliderKNNMaximum.setMaximum(sliderKNN.getMaximum());
                    sliderKFold.setMaximum(application.getKFoldMaximum());
                } else {
                    DocumentClassifierView.mostraMessaggioErrore("Percorso specificato per la directory del training set non valido");
                    referenceField.setText(oldPath);
                }
            } else {
                //Controllo del file con la lista delle stop words
                if (new File(newPath).isFile()) {
                    stopWordsList = newPath;
                } else {
                    DocumentClassifierView.mostraMessaggioErrore("Percorso specificato per la lista delle stopwords non valido");
                    referenceField.setText(oldPath);
                    if(!(new File(oldPath).isFile())) {
                        checkBoxStopWords.setEnabled(false);
                    }
                }
            }
        } catch (Exception ex) {
            DocumentClassifierView.mostraMessaggioErrore(ex.toString());
            /**
             * Se il nuovo valore non è valido, il campo che è stato controllato viene
             * settato al valore precedente, che si suppone essere valido invece
             */
            referenceField.setText(oldPath);
        }
    }
}//GEN-LAST:event_controlloPercorso

    /**
     * Questo metodo ha il compito di sistemare il valore del K-Fold ogni volta che
     * l'utente attiva o disattiva la stratificazione del partizionamento, o di sistemare
     * il valore massimo di KNN per la validazione ogni volta che l'utente modifica
     * il valore di K-Fold.
     * Ciò perchè se la stratificazione viene attivata, i possibili valori di K per il
     * K-Fold sono vincolati in funzione del numero di elementi di ogni categoria del
     * training set che devono essere presenti in ogni partizione.
     * <p>
     * Analogamente, se l'utente modifica il valore del K-Fold tramite l'apposito JSlider,
     * la dimensione del training set corrente rispetto ad ogni fold preso come control set
     * cambia in modo direttamente proporzionale, quindi cambia anche il valore massimo possibile
     * di K per il K-NN.
     * 
     * @param evt
     */
private void sistemaKFold(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_sistemaKFold
    
    int currentKFold = sliderKFold.getValue();
    int dimensioneTrainingSet=application.getTrainingSetSize();
    if (checkBoxStratificazione.isSelected()) {
        final int numeroCategorie = application.getTrainingSet().size();
        Map<Integer, Integer> possibleKFolds = new HashMap<Integer, Integer>();
        Entry<Integer, Integer> distanzaMinima = new AbstractMap.SimpleEntry<Integer,Integer>(0, Integer.MAX_VALUE);
        int i = 1;
        int possibleKFold, distanzaCorrente;
        possibleKFold = dimensioneTrainingSet / (numeroCategorie * i);
        sliderKFold.setMaximum(possibleKFold);
        while (possibleKFold > sliderKFold.getMinimum()) {
            if (!possibleKFolds.containsKey(possibleKFold)) {
                distanzaCorrente = Math.abs(possibleKFold - currentKFold);
                possibleKFolds.put(possibleKFold, distanzaCorrente);
                if (distanzaCorrente < distanzaMinima.getValue()) {
                    distanzaMinima = new AbstractMap.SimpleEntry<Integer,Integer>(possibleKFold, distanzaCorrente);
                }
            }
            i++;
            possibleKFold = dimensioneTrainingSet / (numeroCategorie * i);
        }
        int nuovoKFold=distanzaMinima.getKey();
        sliderKFold.setValue(nuovoKFold);
        sliderKNNMaximum.setMaximum((dimensioneTrainingSet/nuovoKFold/numeroCategorie)*numeroCategorie*(currentKFold-1));
    } else {
        sliderKFold.setMaximum(application.getKFoldMaximum());
        sliderKNNMaximum.setMaximum((dimensioneTrainingSet/currentKFold)*(currentKFold-1));
    }
}//GEN-LAST:event_sistemaKFold

private void checkBoxLoggingItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkBoxLoggingItemStateChanged

    boolean isLoggingEnabled=checkBoxLogging.isSelected();
    fieldLogFile.setEnabled(isLoggingEnabled);
    checkBoxOverwriteLogFile.setEnabled(isLoggingEnabled);
}//GEN-LAST:event_checkBoxLoggingItemStateChanged

    // Variables declaration - do not modify//GEN-BEGIN:variables
    javax.swing.JButton bottoneAnnulla;
    javax.swing.JRadioButton bottoneBhattacharrya;
    javax.swing.JButton bottoneOK;
    javax.swing.JButton bottoneReset;
    javax.swing.JButton bottoneSfogliaDirectoryTrainingSet;
    javax.swing.JButton bottoneSfogliaFileLog;
    javax.swing.JButton bottoneSfogliaStopWords;
    javax.swing.JRadioButton bottoneTFIDF;
    javax.swing.JCheckBox checkBoxLogging;
    javax.swing.JCheckBox checkBoxOverwriteLogFile;
    javax.swing.JCheckBox checkBoxStemming;
    javax.swing.JCheckBox checkBoxStopWords;
    javax.swing.JCheckBox checkBoxStratificazione;
    javax.swing.JCheckBox checkBoxVisualizzaInfoDocumentoCorrente;
    javax.swing.JCheckBox checkBoxVisualizzazioneListaDocumentiCorrelati;
    javax.swing.JComboBox comboBoxScraper;
    javax.swing.JComboBox comboBoxStemmers;
    javax.swing.JTextField fieldDirectoryTrainingSet;
    javax.swing.JTextField fieldLogFile;
    javax.swing.JTextField fieldStopWords;
    javax.swing.ButtonGroup gruppoMetriche;
    javax.swing.JLabel labelDirectoryTrainingSet;
    javax.swing.JLabel labelFileLog;
    javax.swing.JLabel labelKFoldTitle;
    javax.swing.JLabel labelKFoldValue;
    javax.swing.JLabel labelKNNMaximumTitle;
    javax.swing.JLabel labelKNNMaximumValue;
    javax.swing.JLabel labelKNNTitle;
    javax.swing.JLabel labelKNNValue;
    javax.swing.JLabel labelMetrica;
    javax.swing.JLabel labelParser;
    javax.swing.JLabel labelPreprocessing;
    javax.swing.JLabel labelStemmerCorrente;
    javax.swing.JLabel labelStopWords;
    javax.swing.JPanel panelClassificazione;
    javax.swing.JPanel panelPreprocessing;
    javax.swing.JPanel panelTrainingSet;
    javax.swing.JPanel panelValidazione;
    javax.swing.JSeparator separatorFileLogVisualizza;
    javax.swing.JSeparator separatorKFoldLogging;
    javax.swing.JSeparator separatorKNNMaximumKFold;
    javax.swing.JSeparator separatorMetricaKNN;
    javax.swing.JSeparator separatorScraperPreprocessing;
    javax.swing.JSlider sliderKFold;
    javax.swing.JSlider sliderKNN;
    javax.swing.JSlider sliderKNNMaximum;
    javax.swing.JTabbedPane tabbelPanePreferenze;
    private org.jdesktop.beansbinding.BindingGroup bindingGroup;
    // End of variables declaration//GEN-END:variables
    
}
